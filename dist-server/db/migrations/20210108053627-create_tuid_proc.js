'use strict';

module.exports = {
  up: function up(queryInterface, Sequelize) {
    return queryInterface.sequelize.query("\n      CREATE EXTENSION pgcrypto;\n\n\n      -- version 2 of tuid_generate is just random\n      CREATE OR REPLACE FUNCTION tuid_generate()\n        RETURNS UUID AS $$\n      DECLARE\n        ct  BIGINT;\n        r   BYTEA;\n        r0  BIGINT;\n        r1  BIGINT;\n        r2  BIGINT;\n        ax  BIGINT;\n        bx  BIGINT;\n        cx  BIGINT;\n        dx  BIGINT;\n        ret VARCHAR;\n      BEGIN\n        r := gen_random_bytes(8); -- we use 58 bits of this\n\n        r0 := (get_byte(r, 0) << 8) | get_byte(r, 1);\n        r1 := (get_byte(r, 2) << 8) | get_byte(r, 3);\n\n        -- The & mask here is to suppress the sign extension on the 32nd bit.\n        r2 := ((get_byte(r, 4) << 24) | (get_byte(r, 5) << 16) | (get_byte(r, 6) << 8) | get_byte(r, 7)) & x'0FFFFFFFF'::BIGINT;\n\n        ct := extract(EPOCH FROM clock_timestamp() AT TIME ZONE 'utc') * 1000000;\n\n        ax := ct >> 32;\n        bx := ct >> 16 & x'FFFF' :: INT;\n        cx := x'4000' :: INT | ((ct >> 4) & x'0FFF' :: INT);\n        dx := x'8000' :: INT | ((ct & x'F' :: INT) << 10) | (r0 >> 6);\n\n        ret :=\n          LPAD(TO_HEX(ax),8,'0') ||\n          LPAD(TO_HEX(bx),4,'0') ||\n          LPAD(TO_HEX(cx),4,'0') ||\n          LPAD(TO_HEX(dx),4,'0') ||\n          LPAD(TO_HEX(r1),4,'0') ||\n          LPAD(TO_HEX(r2),8,'0');\n\n        return ret :: UUID;\n      END;\n      $$ LANGUAGE plpgsql;\n\n      CREATE OR REPLACE FUNCTION tuid_old_generate()\n        RETURNS UUID AS $$\n      DECLARE\n        ct  BIGINT;\n        seq BIGINT;\n        nid BIGINT;\n        r0  BIGINT;\n        r1  BIGINT;\n        ax  BIGINT;\n        bx  BIGINT;\n        cx  BIGINT;\n        dx  BIGINT;\n        ex  BIGINT;\n        fx  BIGINT;\n        ret VARCHAR;\n      BEGIN\n        seq := 255;\n        nid := 255;\n        ct := extract(EPOCH FROM clock_timestamp() AT TIME ZONE 'utc') * 1000000;\n        r0 := (random() * 4294967295 :: BIGINT) :: BIGINT;\n        r1 := (random() * 4294967295 :: BIGINT) :: BIGINT;\n\n        ax := ct >> 32;\n        bx := ct >> 16 & x'FFFF' :: INT;\n        cx := x'4000' :: INT | ((ct >> 4) & x'0FFF' :: INT);\n        dx := x'8000' :: INT | ((ct & x'F' :: INT) << 10) | (seq << 2) | (nid >> 6);\n        ex := ((nid & x'3F' :: INT) << 2) | (r0 & x'3FF' :: INT);\n        fx := r1;\n\n        ret :=\n          LPAD(TO_HEX(ax),8,'0') ||\n          LPAD(TO_HEX(bx),4,'0') ||\n          LPAD(TO_HEX(cx),4,'0') ||\n          LPAD(TO_HEX(dx),4,'0') ||\n          LPAD(TO_HEX(ex),4,'0') ||\n          LPAD(TO_HEX(fx),8,'0');\n\n        return ret :: UUID;\n      END;\n      $$ LANGUAGE plpgsql;\n\n      -- all random version\n      CREATE OR REPLACE FUNCTION tuid_ar_generate()\n        RETURNS UUID AS $$\n      DECLARE\n        ct  BIGINT;\n        seq BIGINT;\n        nid BIGINT;\n        r0  BIGINT;\n        r1  BIGINT;\n        r2  BIGINT;\n        ax  BIGINT;\n        bx  BIGINT;\n        cx  BIGINT;\n        dx  BIGINT;\n        ex  BIGINT;\n        fx  BIGINT;\n        ret VARCHAR;\n      BEGIN\n        r2 := (random() * 4294967295 :: BIGINT) :: BIGINT;\n        seq := r2 & x'FF' :: INT;\n        nid := (r2 >> 8) & x'FF' :: INT;\n        ct := extract(EPOCH FROM clock_timestamp() AT TIME ZONE 'utc') * 1000000;\n        r0 := (random() * 4294967295 :: BIGINT) :: BIGINT;\n        r1 := (random() * 4294967295 :: BIGINT) :: BIGINT;\n\n        ax := ct >> 32;\n        bx := ct >> 16 & x'FFFF' :: INT;\n        cx := x'4000' :: INT | ((ct >> 4) & x'0FFF' :: INT);\n        dx := x'8000' :: INT | ((ct & x'F' :: INT) << 10) | (seq << 2) | (nid >> 6);\n        ex := ((nid & x'3F' :: INT) << 2) | (r0 & x'3FF' :: INT);\n        fx := r1;\n\n        ret :=\n          LPAD(TO_HEX(ax),8,'0') ||\n          LPAD(TO_HEX(bx),4,'0') ||\n          LPAD(TO_HEX(cx),4,'0') ||\n          LPAD(TO_HEX(dx),4,'0') ||\n          LPAD(TO_HEX(ex),4,'0') ||\n          LPAD(TO_HEX(fx),8,'0');\n\n        return ret :: UUID;\n      END;\n      $$ LANGUAGE plpgsql;  \n  ");
  },
  down: function down(queryInterface, Sequelize) {
    return queryInterface.sequelize.query("\n      drop extension pgcrypto;\n      drop function tuid_generate;\n    ");
  }
};